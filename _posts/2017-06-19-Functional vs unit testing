---
layout: post
title: 'Functional vs unit testing'
date: 2017-06-19
---
I posted some time ago about how I fixed a memory leak. This process changed (or reverted back) my view on testing and in this post I explain how. Recently I wrote about (the return of investment for automatic testing)[] and you may want to take a look.

Very early in my career I started doing automatic testing on my projects. It was a disorganized test suite that covered the functionalities of the software I was building. There were no unit tests. The suite did its work and I delivered a stable product.

Then I learned that one is supposed to write unit tests (in addition to functional tests). The tests has to be written first. There is test driven development and many more things. And all of these techniques and methodologies were well founded. I don't mean in this post they are not, but after some years of developing I finally decided to drop all that and come back to focus on functional test suites. Why?

In the last years I have been trying to build a unit test base in all my projects. You are supposed to test early so that your code is testable. If it is not, then your unit is doing too many things and you have to refactor it into smaller units. You have to make it testable.

The benefits of unit testing is that, at this small scale, they identify very clearly where is the bug. This reduces a lot the time for debugging. But in my experience, unit tests introduce hidden costs:

1. Unit tests affect your code. You have to make your code testable. I don't think testable units lead to the design that is best for the development process so unit testing is getting on the way to design.

2. Unit tests affect your code. Typing code introduces bugs. You can read how this changes made me introduce a memory leak in my code [here](http://fergonco.org/2017/04/13/Docker-container-Java-heap-dump-analysis-(follow-up).html). In this case the cost to fix the defect introduced to make the code testable was quite high.

3. Unit tests require a lot of maintenance. Units evolve a lot and unit tests have to evolve along. They may even disappear: some units may be replaced by some third party library or whatever and not be necessary anymore. I don't want to base my test investment on volatile units. 

So from now on I will go back to a strong functional test suite and I will write unit tests for specially complex units that I think will remain long in the project.
